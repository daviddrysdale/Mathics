.. pymathics-hello documentation master file, created by
   sphinx-quickstart on Sun Nov 29 14:06:02 2020.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

.. toctree::
   :maxdepth: 2
   :caption: Contents:

Adding builtin symbols
======================

Adding new built-in symbols to Mathics is very easy. Either place a new module
in the builtin directory and add it to the list of modules in
``builtin/__init__.py`` or use an existing module. Create a new class derived
from ``Builtin``.

To get an idea of how a built-in class can look like, consider the following
implementation of ``Hello``:

.. code-block:: python
  from mathics.builtin.base import Builtin

  class Hello(Builtin):
    """
    <dl>
      <dt>Hello[$person$]
      <dd>An example function in a Python-importable Mathics module.
    </dl>
    >> Hello["World"]
     = Hello, World!
    """
    def apply(self, person, evaluation):
      "Hello[person_]"
      return String(f"Hello, {person.get_string_value()}!")

The class starts with a Python docstring that specifies the documentation and
tests for the symbol.  Please refer to `Documentation markup
<https://github.com/mathics/Mathics/wiki/Documentation-markup>`_ for more
details on how to write the documentation.

Python functions starting with "apply" are converted to built-in rules. Their
docstring is compiled to the corresponding Mathics pattern. Pattern variables
used in the pattern are passed to the Python function by their same name, plus
an additional evaluation object. This object is needed to evaluate further
expressions, print messages in the Python code, etc. Unsurprisingly, the return
value of the Python function is the expression that is replaced for the matched
pattern. If the function does not return any value, the Mathics expression is
left unchanged. Note that you have to return ``Symbol["Null"]`` explicitly if
you want that.

The arguments to between ``self`` and ``evaluation`` are bound to the Python
representation of the arguments passed to the builtin at runtime. The
``evaluation`` argument stores information about variable bindings (it's an
instance of ``mathics.core.evaluation.Evaluation``).

Working with multiple evaluators
================================

It's important to note that a builtin can have *more than one evaluator*,
such as in the following case:
    
.. code-block:: python
  from mathics.builtin.base import Builtin, String

  class Hello(Builtin):
    """
    <dl>
      <dt>Hello[$person$]
      <dd>An example function in a Python-importable Mathics module.
    </dl>
    >> Hello["World"]
     = Hello, World!
    """

    def apply(self, person, language, evaluation):
      "Hello[person_, language_]"

      if language.has_form("French"):
        return String(f"Bonjour, {person.get_string_value()}!")
      else:
        return String(f"Hello, {person.get_string_value()}!")

    def apply_english(self, person, evaluation):
      "Hello[person_]"
      return self.apply(person, Expression("English"), evaluation)

In this case, ``Hello["Peter", French]`` will resolve to ``"Bonjour,
Peter!"``, while ``Pymathics`Hello["Peter", English]`` or
``Pymathics`Hello["Peter"]`` will both resolve to ``"Hello, Peter!"``. When
evaluating a call to a builtin, Mathics will patter-match on the arity of the
call and use the most appropriate evaluator.

Type-checking the inputs
========================

We may want to use different evaluators according to the types of the arguments
passed to a builtin. We can do so by specifying type-constraints in the
evaluator's docstring, such as in the following example:

.. code-block:: python
  from mathics.builtin.base import Builtin

  class Hello(Builtin):
    """
    <dl>
      <dt>Hello[$person$]
      <dd>An example function in a Python-importable Mathics module.
    </dl>
    >> Hello["World"]
     = Hello, World!
    """

    def apply(self, person, evaluation):
      "Hello[person_String]"
      return String(f"Hello, {person.get_string_value()}!")

When evaluating a call to a builtin, Mathics will check the types of the inputs
and search for the most appropriate evaluator. If no evaluator matches the types
of the inputs, the expression is returned unchanged. For example, if we
implemented ``Hello`` as above then ``Hello[45]`` would
resolve to ``Hello[45]``, because no evaluator matches the type of
``45``.

Rules
=====

Let's recall the example given in `Working with multiple evaluators`_. Notice
that ``English`` is essentially the default value of the ``language``. We
don't actually need to create multiple evaluators to encode parameters with
default values. By adding an entry to the builtin's ``rules`` class-field, we
can tell Mathics that an expression should resolve the value of a different
expression, such as in the following example:

.. code-block:: python
  from mathics.builtin.base import Builtin, String

  class Hello(Builtin):
    """
    <dl>
      <dt>Hello[$person$]
      <dd>An example function in a Python-importable Mathics module.
    </dl>
    >> Hello["World"]
     = Hello, World!
    """

    rules = {
      "Hello[person_]": "Hello[person, English]",
    }

    def apply(self, person, language, evaluation):
      "Hello[person_, language_]"

      if language.has_form("French"):
        return String(f"Bonjour, {person.get_string_value()}!")
      else:
        return String(f"Hello, {person.get_string_value()}!")

Special attributes
==================

One can specify general attributes of a builtin in it's ``attributes``
class field. For example, let's say you expect ``Hello[{"Peter",
"Roger"}]`` to evaluate to the same as ``{Hello["Peter"],
Hello["Roger"]}``. We can to that by overwriting ``Hello``'s
``attributes`` class-field.

.. code-block:: python
  from mathics.builtin.base import Builtin, String

  class Hello(Builtin):
    """
    <dl>
      <dt>Hello[$person$]
      <dd>An example function in a Python-importable Mathics module.
    </dl>
    >> Hello["World"]
     = Hello, World!
    """

    attributes = ('Listable',)

    def apply(self, person, evaluation):
      "Hello[person_]"

      return String(f"Hello, {person.get_string_value()}!")

.. TODO: Document what which attribute does. Place a table in here

Emitting warnings
=================

Sometimes things go wrong. When things go wrong, we should report an error to
our users. But how can one emit a warning from inside an evaluator? 

Warnings in Mathics can be specified via the ``messages`` class field. The
``messages`` class field is a dictionary whose keys are the names of possible
warning messages and whose values are template warning messages. For example,
we may want to display a warning when our users pass something other than a
string to ``Hello``:

.. code-block:: python
  from mathics.builtin.base import Builtin, String

  class Hello(Builtin):
    """
    <dl>
      <dt>Hello[$person$]
      <dd>An example function in a Python-importable Mathics module.
    </dl>
    >> Hello["World"]
     = Hello, World!
    """

    messages = {
      'nstr': '`1` is not a string',
    }

    def apply(self, person, evaluation):
      "Hello[person_]"

      if not person.has_form('String'):
        return evaluation.message('Hello', 'nstr', person)

      return String(f"Hello, {person.get_string_value()}!")

In this case, calling ``Hello[45]`` will emit the warning ``nstr: 45
is not a string``.

.. TODO: Document Operator and SympyFunction
.. TODO: Document interupts

Indices and tables
==================

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`
